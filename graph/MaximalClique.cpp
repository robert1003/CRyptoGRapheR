#define N 80
struct MaxClique{ // 0-base
  typedef bitset<N> Int;
  Int lnk[N],v[N]; int n;
  void init(int _n){
    n=_n;
    for(int i=0;i<n;i++){
      lnk[i].reset(); v[i].reset();
    }
  }
  void addEdge(int a,int b) { v[a][b]=v[b][a]=1; }
  int ans,stk[N],id[N],di[N],deg[N]; Int cans;
  void dfs(int elem_num,Int candi,Int ex){
    if(candi.none()&&ex.none()){
      cans.reset();
      for(int i=0;i<elem_num;i++) cans[id[stk[i]]]=1;
      ans=max(ans,elem_num); // cans is a maximal clique
      return;
    }
    int pivot=(candi|ex)._Find_first();
    Int smaller_candi=candi&(~lnk[pivot]);
    while(smaller_candi.count()){
      int nxt=smaller_candi._Find_first();
      candi[nxt]=smaller_candi[nxt]=0;
      ex[nxt]=1; stk[elem_num]=nxt;
      dfs(elem_num+1,candi&lnk[nxt],ex&lnk[nxt]);
    }
  }
  int solve(){
    for(int i=0;i<n;i++){id[i]=i; deg[i]=v[i].count();}
    sort(id,id+n,[&](int id1,int id2)
        { return deg[id1]>deg[id2]; });
    for(int i=0;i<n;i++) di[id[i]]=i;
    for(int i=0;i<n;i++) for(int j=0;j<n;j++)
        if(v[i][j]) lnk[di[i]][di[j]]=1;
    ans=0; cans.reset(); cans[0]=1;
    dfs(0,Int(string(n,'1')),0);
    return ans;
  }
}graph;
