const int MAXN=100010;
struct DominatorTree{
#define REP(i,s,e) for(int i=(s);i<=(e);i++)
#define REPD(i,s,e) for(int i=(s);i>=(e);i--)
  int n,m,s; vector<int> g[MAXN],pred[MAXN],cov[MAXN];
  int dfn[MAXN],nfd[MAXN],ts,par[MAXN];
  int sdom[MAXN],idom[MAXN],mom[MAXN],mn[MAXN];
  inline bool cmp(int u,int v){ return dfn[u] <dfn[v]; }
  int eval(int u){
    if(mom[u]==u) return u;
    int res=eval(mom[u]);
    if(cmp(sdom[mn[mom[u]]],sdom[mn[u]]))
      mn[u]=mn[mom[u]];
    return mom[u]=res;
  }
  void init(int _n,int _m,int _s){
    ts=0; n=_n; m=_m; s=_s;
    REP(i,1,n) g[i].clear(),pred[i].clear();
  }
  void addEdge(int u,int v){
    g[u].push_back(v); pred[v].push_back(u);
  }
  void dfs(int u){
    ts++; dfn[u]=ts; nfd[ts]=u;
    for(int v:g[u]) if(dfn[v]==0){ par[v]=u; dfs(v); }
  }
  void build(){
    REP(i,1,n){
      dfn[i]=nfd[i]=0; cov[i].clear();
      mom[i]=mn[i]=sdom[i]=i;
    }
    dfs(s);
    REPD(i,n,2){
      int u=nfd[i];
      if(u==0) continue ;
      for(int v:pred[u]) if(dfn[v]){
        eval(v);
        if(cmp(sdom[mn[v]],sdom[u]))sdom[u]=sdom[mn[v]];
      }
      cov[sdom[u]].push_back(u); mom[u]=par[u];
      for(int w:cov[par[u]]){
        eval(w);
        if(cmp(sdom[mn[w]],par[u])) idom[w]=mn[w];
        else idom[w]=par[u];
      }
      cov[par[u]].clear();
    }
    REP(i,2,n){
      int u=nfd[i];
      if(u==0) continue;
      if(idom[u]!=sdom[u]) idom[u]=idom[idom[u]];
    }
  }
} domT;
